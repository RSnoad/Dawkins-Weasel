import re
import random
from Dawkins_Weasel import startingString
from Dawkins_Weasel import copiesString
from Dawkins_Weasel import mutate
from Dawkins_Weasel import mutateList
from Dawkins_Weasel import evolution

def test_CanCreateStringOfLength28():
    assert len(startingString()) == 28

def test_GeneratedStringOnlyContainsCapitalLettersAndSpaces():
    regex = re.compile(r'[^A-Z ]')
    filtered = regex.search(startingString())
    assert filtered is None
    # if filtered:
    #     assert filtered.group() == ''

# Test to see if string is 'randomly' generated by forcing a specific seed.
# The forcing a seed method may class as testing implementation rather than behaviour ie. test would
# need to be rewritten if we stopped using the random library and replaced it with something else.
# This test will also need to be changed if the length of the string or properties of the string are changed.
def test_CanGenerateARandomString():
    random.seed(100)
    assert startingString() == "DMUTTLVOCMBZZJIUFEFJQ FZOYWE"
    random.seed(200)
    assert startingString() == "BFTDXHALEAHMFXISJCLSNRDDDNXK"
    random.seed(300)
    assert startingString() == "QJAJWLPELJDGCXNNUSIXPZHJBVQV"

# Alternative implementation of a test the checks if the string is generated randomly. This test does not have
# the same issues that the above test has, however it is still a flawed test in that
# there is a chance that it will fail when it should have passed.
def test_CanGenerateARandomStringSecondTest():
    string1 = startingString()
    string2 = startingString()
    string3 = startingString()
    string4 = startingString()
    string5 = startingString()
    # Believe this is equivalent to (string1 == string2) and (string2 == string3) etc.
    assert not string1 == string2 == string3 == string4 == string5

def test_CanMake100CopiesOfGeneratedString():
    copies = copiesString()
    assert all(i == copies[0] for i in copies)

# As with previous seeded test this seems like implementation over behaviour and also breaks the flow of TDD.
def test_CanMutateAString():
    random.seed(100)
    mutatedString = mutate('DNRRZYQSHWVDWKVBRXTL IOCYUPC')
    assert mutatedString == "DNRRZYQSHWUDWKVBRXTL IOCYUPC"


def test_MutatedStringIsOfCorrectLength():
    mutatedString = mutate(startingString())
    assert len(mutatedString) == 28

# As with the similar test above there is some potential unreliability as it is possible that all
# strings end up being mutated the same by pure chance.
def test_MutatedListContainsElementsThatAreNotAllEqual():
    originalList = copiesString()
    mutatedList = mutateList(originalList)
    assert not all(i == mutatedList[0] for i in mutatedList)

# Under TDD if we only have this test we can just make this function return the required output directly,
# but not sure how I can test this further. Flow of TDD broke down while creating the evolution() function.
def test_CanMutateToTargetString():
    assert evolution() == "METHINKS IT IS LIKE A WEASEL"





